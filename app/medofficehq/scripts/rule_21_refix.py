"""
Rule 21 Refix: Remove Incorrectly Added Modifier 25

This script removes modifier 25 from services that were incorrectly added by the previous rule21 logic.
It reads the CSV file generated by rule21 and removes modifiers from all services that were modified.

Structure:
1. Data Reading - Read the CSV file from rule21
2. Modifier Removal - Remove modifier 25 from all modified services
3. Export - Generate CSV report with removal results

Author: Your Name
Date: 2025-01-07
Version: 1.0
"""

import sys
import os
import logging
import csv
import asyncio
import httpx
from datetime import datetime
from typing import Dict, List, Optional
from pydantic import BaseModel

# Add the parent directory to the path so we can import from app
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from app.core.config import settings
    from app.services.athena_service import AthenaService
except ImportError:
    # Fallback for when running directly
    import os
    from pydantic_settings import BaseSettings
    
    class Settings(BaseSettings):
        ATHENA_API_BASE_URL: str = os.getenv("ATHENA_API_BASE_URL", "")
        ATHENA_PRACTICE_ID: str = os.getenv("ATHENA_PRACTICE_ID", "")
        ATHENA_Client_ID: str = os.getenv("ATHENA_Client_ID", "")
        ATHENA_Client_Secret: str = os.getenv("ATHENA_Client_Secret", "")
        
        class Config:
            env_file = ".env"
            case_sensitive = True
    
    settings = Settings()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Rule21RefixRequest(BaseModel):
    """Request model for Rule 21 Refix"""
    csv_filename: str
    dry_run: bool = False

class Rule21RefixResponse(BaseModel):
    """Response model for Rule 21 Refix"""
    success: bool
    message: str
    total_processed: int
    total_removed: int
    csv_filename: Optional[str] = None
    details: Optional[dict] = None

class Rule21Refix:
    """
    Rule 21 Refix: Remove Incorrectly Added Modifier 25
    
    This script removes modifier 25 from services that were incorrectly added by the previous rule21 logic.
    """
    
    def __init__(self):
        """Initialize Rule 21 Refix"""
        self.name = "Rule 21 Refix - Remove Incorrectly Added Modifier 25"
        self.version = "1.0"
        
        # API configuration
        self.base_url = settings.ATHENA_API_BASE_URL
        self.practice_id = settings.ATHENA_PRACTICE_ID
        
        # Initialize AthenaService for API calls
        self.athena_service = AthenaService()
        
        logger.info(f"Initialized {self.name} v{self.version}")
        logger.info(f"Practice ID: {self.practice_id}")
    
    # ============================================================================
    # 1. DATA READING - Read CSV file from rule21
    # ============================================================================
    
    def read_rule21_csv(self, csv_filename: str) -> List[Dict]:
        """Read the CSV file generated by rule21"""
        try:
            missing_slips = []
            
            with open(csv_filename, 'r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    missing_slips.append(row)
            
            print(f"‚úÖ Read {len(missing_slips)} records from {csv_filename}")
            return missing_slips
            
        except FileNotFoundError:
            print(f"‚ùå File not found: {csv_filename}")
            return []
        except Exception as e:
            print(f"‚ùå Error reading CSV file: {e}")
            return []
    
    # ============================================================================
    # 2. MODIFIER REMOVAL - Remove modifier 25 from services
    # ============================================================================
    
    async def get_encounter_services(self, encounter_id: str, token: Optional[str] = None) -> List[Dict]:
        """Fetch services/procedures for a specific encounter"""
        try:
            # Get access token if not provided
            if not token:
                token = await self.athena_service.get_access_token()
            
            # Create a custom request with longer timeout
            async with httpx.AsyncClient(verify=True, timeout=httpx.Timeout(120.0)) as client:
                url = f"{self.athena_service.base_url}/{settings.ATHENA_PRACTICE_ID}/encounter/{encounter_id}/services"
                
                headers = {
                    "Authorization": f"Bearer {token}",
                    "Content-Type": "application/json"
                }
                
                logger.info(f"Making services request for encounter {encounter_id}")
                
                response = await client.get(url, headers=headers)
                response.raise_for_status()
                
                data = response.json()
                procedures = data.get('procedures', [])
                logger.info(f"Found {len(procedures)} procedures for encounter {encounter_id}")
                
                return procedures
                
        except httpx.ReadTimeout as e:
            logger.error(f"Services request timed out for encounter {encounter_id}: {str(e)}")
            return []
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error for encounter {encounter_id}: {e.response.status_code}")
            return []
        except Exception as e:
            logger.error(f"Error making services API request for encounter {encounter_id}: {str(e)}")
            return []

    async def remove_modifier_25_from_service(self, encounter_id: str, service_id: str, token: Optional[str] = None) -> bool:
        """Remove modifier 25 from a service"""
        try:
            # Get access token if not provided
            if not token:
                token = await self.athena_service.get_access_token()
            
            # Create a custom request with longer timeout
            async with httpx.AsyncClient(verify=True, timeout=httpx.Timeout(120.0)) as client:
                url = f"{self.athena_service.base_url}/{settings.ATHENA_PRACTICE_ID}/encounter/{encounter_id}/services/{service_id}"
                
                headers = {
                    "Authorization": f"Bearer {token}",
                    "Content-Type": "application/x-www-form-urlencoded"
                }
                
                # Prepare the form data payload - remove all modifiers
                form_data = {
                    "modifiers": "[]",  # Empty array to remove all modifiers
                    "billforservice": "true"
                }
                
                logger.info(f"Removing modifier 25 from service {service_id} in encounter {encounter_id}")
                
                response = await client.put(url, headers=headers, data=form_data)
                response.raise_for_status()
                
                # Check if the update was successful
                if response.status_code == 200:
                    logger.info(f"‚úÖ Successfully removed modifier 25 from service {service_id}")
                    return True
                else:
                    logger.error(f"‚ùå Failed to remove modifier 25 from service {service_id}")
                    return False
                
        except httpx.ReadTimeout as e:
            logger.error(f"Update request timed out for service {service_id}: {str(e)}")
            return False
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error for service {service_id}: {e.response.status_code}")
            logger.error(f"Response body: {e.response.text}")
            return False
        except Exception as e:
            logger.error(f"Error updating service {service_id}: {str(e)}")
            return False

    async def remove_modifiers_from_missing_slips(self, missing_slips: List[Dict], token: str, dry_run: bool = False) -> int:
        """Remove modifier 25 from all services in missing slips"""
        print("üîß Removing modifier 25 from services...")
        
        total_processed = 0
        total_removed = 0
        
        for slip in missing_slips:
            encounter_id = slip.get('encounter_id', '')
            if not encounter_id:
                continue
                
            # Only process if this slip had modifiers added
            if not slip.get('modifier_added_successfully', False):
                continue
                
            print(f"üîç Processing encounter {encounter_id} for modifier removal...")
            
            # Get the services for this encounter
            procedures = await self.get_encounter_services(encounter_id, token)
            
            if not procedures:
                continue
                
            # Track success for this slip
            slip_success = False
            services_found = False
            
            # Check each procedure for modifier removal
            for procedure in procedures:
                service_id = procedure.get('serviceid', '')
                
                if service_id:
                    total_processed += 1
                    services_found = True
                    print(f"  üìù Removing modifier 25 from service {service_id}")
                    
                    if not dry_run:
                        # Remove modifier 25
                        success = await self.remove_modifier_25_from_service(encounter_id, service_id, token)
                        if success:
                            total_removed += 1
                            slip_success = True
                    else:
                        print(f"    [DRY RUN] Would remove modifier 25 from service {service_id}")
                        total_removed += 1
                        slip_success = True
                    
                    # Add delay to avoid rate limiting
                    await asyncio.sleep(0.5)
            
            # Update the slip with removal success status
            if services_found:
                slip['modifier_removed_successfully'] = slip_success
            else:
                slip['modifier_removed_successfully'] = False
        
        print(f"‚úÖ Modifier 25 removal complete: {total_removed}/{total_processed} services processed")
        return total_removed

    # ============================================================================
    # 3. EXPORT - Generate reports and exports
    # ============================================================================
    
    def export_removal_results_to_csv(self, missing_slips: List[Dict], filename: Optional[str] = None) -> str:
        """Export modifier removal results to CSV file"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"rule_21_refix_removal_results_{timestamp}.csv"
        
        if not missing_slips:
            print("No data to export")
            return ""
        
        fieldnames = [
            'appointment_id', 'patient_id', 'patient_name', 'appointment_date', 
            'appointment_type', 'encounter_state', 'encounter_status', 'encounter_id',
            'charge_entry_not_required', 'department_id', 'provider_id', 
            'insurance_provider', 'insurance_member_id', 'missing_reason', 
            'claims_count', 'procedures_count', 'procedure_code_present', 'addmodifier',
            'modifier_added_successfully', 'modifier_removed_successfully', 'copay_amount', 
            'scheduled_datetime', 'checkin_datetime', 'checkout_datetime'
        ]
        
        try:
            with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(missing_slips)
            
            print(f"‚úÖ Data exported successfully to {filename}")
            print(f"üìÑ Total records exported: {len(missing_slips)}")
            return filename
            
        except Exception as e:
            print(f"‚ùå Error exporting to CSV: {e}")
            return ""

    # ============================================================================
    # MAIN EXECUTION - Orchestrate the entire process
    # ============================================================================
    
    async def run(self, request: Rule21RefixRequest) -> Rule21RefixResponse:
        """
        Main execution method for Rule 21 Refix
        
        Args:
            request: Rule21RefixRequest with CSV filename and dry run flag
            
        Returns:
            Rule21RefixResponse with removal results
        """
        try:
            print("üöÄ Rule 21 Refix: Remove Incorrectly Added Modifier 25")
            print("=" * 50)
            print("This script removes modifier 25 from services that were incorrectly added")
            print("by the previous rule21 logic.")
            if request.dry_run:
                print("‚ö†Ô∏è  DRY RUN MODE - No actual changes will be made")
            print("=" * 50)
            
            # Step 1: Read the CSV file from rule21
            print(f"üìã Reading CSV file: {request.csv_filename}")
            missing_slips = self.read_rule21_csv(request.csv_filename)
            
            if not missing_slips:
                return Rule21RefixResponse(
                    success=False,
                    message="No data found in CSV file",
                    total_processed=0,
                    total_removed=0
                )
            
            print(f"‚úÖ Found {len(missing_slips)} records to process")
            
            # Step 2: Get a single token to reuse for all API calls
            token = await self.athena_service.get_access_token()
            
            # Step 3: Remove modifiers from all services
            total_removed = await self.remove_modifiers_from_missing_slips(
                missing_slips, 
                token, 
                request.dry_run
            )
            
            # Step 4: Export results to CSV
            csv_filename = self.export_removal_results_to_csv(missing_slips)
            
            return Rule21RefixResponse(
                success=True,
                message=f"Modifier removal complete. Processed {len(missing_slips)} records, removed {total_removed} modifiers.",
                total_processed=len(missing_slips),
                total_removed=total_removed,
                csv_filename=csv_filename,
                details={
                    "dry_run": request.dry_run,
                    "original_csv": request.csv_filename
                }
            )
            
        except Exception as e:
            logger.error(f"Error in Rule 21 Refix execution: {str(e)}")
            return Rule21RefixResponse(
                success=False,
                message=f"Error during modifier removal: {str(e)}",
                total_processed=0,
                total_removed=0
            )

# Global instance for API use
rule_21_refix_instance = Rule21Refix()

async def main():
    """Main function for standalone execution"""
    # You can specify the CSV filename here
    csv_filename = "rule_21_missing_slips_20250718_173836.csv"  # Most recent CSV file
    
    request = Rule21RefixRequest(
        csv_filename=csv_filename,
        dry_run=False  # Set to False to actually remove modifiers
    )
    
    result = await rule_21_refix_instance.run(request)
    print(f"\nüìã Removal Summary:")
    print(f"Success: {result.success}")
    print(f"Message: {result.message}")
    print(f"Total processed: {result.total_processed}")
    print(f"Total removed: {result.total_removed}")
    if result.csv_filename:
        print(f"CSV file: {result.csv_filename}")

if __name__ == "__main__":
    asyncio.run(main()) 